#  缓存

通过复用以前获取的资源，可以显著提高网站和应用程序的性能。Web 缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。通过使用 HTTP缓存，变得更加响应性。


## 不同种类的缓存

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。
当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：

 - 缓解服务器端压力。
 - 提升性能(获取资源的耗时更短了)。


#### 缓存的类型

 - 私有缓存(强缓存)(浏览器缓存-只能用于单独用户),浏览器不会向服务器发送任何请求,直接从本地缓存读取文件并返回`200`
 - 共享缓存(协商缓存)(代理缓存-能够被多个用户使用)
 - 强缓存命中，不会请求服务器，直接请求缓存；协商缓存命中，会请求服务器，不会返回内容，然后读取缓存；

![cacheType](./cacheType.png)


## 缓存操作

缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）

普遍的缓存案例

 - `GET`请求,响应码`200`
 - 永久重定向,响应码`301`
 - 错误响应,响应码`404`
 - 不完全的响应,状态码`206`,只返回局部的信息
 - 除了`GET`请求外,如果匹配到一个已被定义的cache键名的响应



## 缓存控制



#### Cache-control请求头-强缓存

**HTTP/1.1**定义的 `Cache-Control `头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。

- 没有缓存 `Cache-Control: no-store`

- 缓存但是重新校验,若未过期则返回304 `Cache-Control: no-cache`   

- 私有缓存,该缓存只能用于浏览器私有缓存中 `Cache-Control: private`

- 公共缓存,可以被任何中间人缓存 `Cache-Control: public`

- 过期时间,秒,表示可以被缓存的最大时间,如果在生命周期内,则命中缓存  ` Cache-Control: max-age=31536000`

- 缓存校验,已过期的缓存将不再使用,缓存验证章节详细介绍 `Cache-Control: must-revalidate`

  

#### Pragma请求头

`Pragma` 是**HTTP/1.0**标准中定义的一个header属性

请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头没有明确定义这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。



#### Expires请求头-强缓存

Expires:过期时间,该值是一个GMT时间格式个字符串，浏览器进行第一次请求时，服务器会在返回头部加上Expires，下次请求，如果在这个时间之前则命中缓存



#### 新鲜度

当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个`If-None-Match`头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 `304` (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。

若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。

`Cache-control: max-age=N`请求头,相对应的缓存的寿命就是`N`,通常情况下不含这个属性的时候,就会去查看Expires属性,判断缓存是否有效

如果max-age和expires属性都没有,找找请求头里面的`Last-Modified`信息,如果有缓存的寿命就等于头里面的Date的值减去`Last-Modified`的值除于10.



![HTTPStaleness](./HTTPStaleness.png)





## webpack打包文件的hash值

文件名后面加上hash值,文件内容变动后hash值就会变动,就会被视为新的独立的资源



## 缓存验证

如果在缓存的响应头信息里面含有`Cache-control: must-revalidate`,在浏览的过程中就会触发缓存验证,





#### ETags-协商缓存

`200`表示返回正常的结果,`304`表示浏览器可以用本地缓存文件



#### **If-None-Match**

服务器比较请求头中的If-None-Match和当前资源中的etag是否一致，来判断资源是否修改过，如果没有修改，则命中缓存，浏览器从缓存中读取资源，如果修改过，服务器会返回新的etag，并返回资源



#### Last-Modified , If-Modified-Since

`Last-Modified`表示资源的最后更新时间,

`If-Modified-Since`通过比较两次的时间判断,资源在请求期间是否有修改



## Vary响应



`Varyx`HTTP响应头决定了对于后续的请求头,如何判断是请求一个新的资源还是使用缓存的文件



当缓存服务器收到一个请求,只有当前的请求和原始(缓存)的请求头跟缓存的响应头里的Vary都匹配,才能使用缓存的响应



![HTTPVary](./HTTPVary.png)

使用vary头有利于内容服务的动态多样性。例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。



> ```html
> Vary: User-Agent
> ```



## from memory cache 和 from disk cache的区别

from memory cache：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况

from disk cache：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache

